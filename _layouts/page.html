<!DOCTYPE html>

<html lang="{{ page.lang | default: site.lang | default: "en-us" }}">

    <head>

        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

        <meta property="og:description" content="{{ site.description }}">

        <meta property="og:image" content="{{ site.image }}">

        {%- capture title -%}
            {%- if page.title -%}
                {{- page.title -}}
            {%- endif -%}
            {%- if site.title -%}
                {%- unless site.github and site.title == site.github.repository_name -%}
                    {%- if page.title %} - {% endif -%}
                    {{- site.title -}}
                {%- endunless -%}
            {%- endif -%}
        {%- endcapture %}

        <meta property="og:title" content="{{ title }}">

        <meta property="og:url" content="{{ site.url }}">

        <link href="{{ '/favicon.ico' | relative_url }}?{{ site.time | date: '%s' }}" rel="icon">

        <!-- https://fontawesome.com/how-to-use/on-the-web/referencing-icons/basic-use -->
        <link crossorigin="anonymous" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" rel="stylesheet">

        <link href="{{ '/assets/css/style.css' | relative_url }}?{{ site.time | date: '%s' }}" rel="stylesheet">

        <!-- http://getbootstrap.com/docs/4.3/getting-started/introduction/ -->
        <script crossorigin="anonymous" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
        <script crossorigin="anonymous" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"></script>
        <script crossorigin="anonymous" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"></script>

        <script>

            /* https://github.com/Zod-/jsVideoUrlParser */
            {% include jsVideoUrlParser.min.js %}

        </script>

        <script>

            $(document).on('DOMContentLoaded', function() {

                // Add toggler
                let nav = $('aside nav.collapse');
                let button = $('<button aria-expanded="false" class="btn btn-sm collapsed" data-toggle="collapse">Menu</button>');
                nav.before(button);
                button.click(function() {
                    nav.collapse('toggle');
                    $(this).toggleClass('collapsed');
                    $(this).attr('aria-expanded', ($(this).attr('aria-expanded') === 'false') ? 'true' : 'false');
                });

                // Get headings
                let $headings = $([
                    'main.markdown-body h2',
                    'main.markdown-body h3',
                    'main.markdown-body h4',
                    'main.markdown-body h5',
                    'main.markdown-body h6'].join(','));

                // Add anchors to headings
                $headings.each(function(index, element) {
                    if ($(element).attr('id') && $(element).has('a').length === 0) {
                        $(element).wrapInner($('<a href="#' + $(element).attr('id') + '"></a>'));
                    }
                });

                // Parse Kramdown extensions
                try {

                    // Stack for extensions' start tags
                    let stack = [];

                    // Tokenize HTML surrounding extensions' start tags and end tags
                    let tokens = $('.markdown-body').html().split(/({::\w+(?:(?!\\).{1}|^)*?\/?}|{:\/\w*})/);

                    // Iterate over tokens
                    for (let i = 0, matches; i < tokens.length; i++) {

                        // If a start tag
                        if (matches = tokens[i].match(/^{::(\w+)(?:(?!\\).{1}|^)*?(\/?)}$/)) {

                            // Extension's name
                            const tagName = matches[1];

                            // Convert to custom HTML component, decurling any quotes
                            tokens[i] = tokens[i].replace(/^{::/, '<x-').replace(/‘|’/g, "'").replace(/“|”/g, '"');

                            // If no body present or a bodyless extension
                            if (matches[2] || ['next', 'video'].indexOf(tagName) > -1) {

                                // End element
                                tokens[i] = tokens[i].replace(/\/?}$/, '/>');
                            }

                            // If body potentially present
                            else {

                                // End tag but not element
                                tokens[i] = tokens[i].replace(/}$/, '>');

                                // Remember extension's name
                                stack.push(tagName);
                            }
                        }

                        // If an end tag
                        else if (matches = tokens[i].match(/^{:\/(\w*)}$/)) {

                            // Extension's name
                            let tagName = matches[1];

                            // If nothing to pop
                            if (!stack.length) {
                                throw new Error('Unexpected end tag: ' + tagName);
                            }

                            // If end tag doesn't match start tag
                            const top = stack.pop();
                            if (tagName.length) {
                                if (tagName !== top) {
                                    throw new Error('Unexpected end tag: ' + tagName);
                                }
                            }

                            // If closed anonymously with {:/}
                            else {
                                tagName = top;
                            }

                            // End element
                            tokens[i] = '</x-' + tagName + '>';
                        }

                        // If token has any preceding siblings
                        if (i > 0) {

                            // Match nearest opened paragraph
                            const matches = tokens[i - 1].match(/<p>([\s\S]*?)$/);
                            if (matches) {

                                // If paragraph contains other content
                                if (matches[1] && !matches[1].match(/<\/p>/)) {

                                    // Close paragraph
                                    tokens[i - 1] = tokens[i - 1].replace(/\s*$/, '') + '</p>';
                                }

                                // Else remove paragraph's start tag
                                else {
                                    tokens[i - 1] = tokens[i - 1].replace(/<p>\s*$/, '');
                                }
                            }
                        }

                        // If token has any following siblings
                        if (i + 1 < tokens.length) {

                            // Match nearest closed paragraph
                            const matches = tokens[i + 1].match(/^([\s\S]*?)<\/p>/);
                            if (matches) {

                                // If paragraph contains other content
                                if (matches[1] && !matches[1].match(/<\/p>/)) {

                                    // Re-open paragraph
                                    tokens[i + 1] = '<p>' + tokens[i + 1].replace(/^\s*/, '');
                                }

                                // Else remove paragraph's end tag
                                else {
                                    tokens[i + 1] = tokens[i + 1].replace(/^\s*<\/p>/, '');
                                }
                            }
                        }
                    }

                    // Replace HTML with modified tokens
                    $('.markdown-body').html(tokens.join(''));

                    // Render x-video
                    $('x-video').each(function(index, element) {

                        // Default parameters
                        const PARAMS = {
                            'dailymotion': {
                            },
                            'twitch': {
                                'autoplay': 0,
                            },
                            'vimeo': {
                                'autoplay': 0,
                            },
                            'wistia': {
                            },
                            'youtube': {
                                'autoplay': 0,
                                'rel': 0,
                                'showinfo': 0
                            }
                        };

                        // Parse URL
                        let videoInfo = urlParser.parse($(element).attr('src'));
                        if (videoInfo && Object.keys(PARAMS).indexOf(videoInfo.provider) > -1) {

                            // Inject parameters
                            let params = PARAMS[videoInfo.provider];
                            if (videoInfo.params) {
                                for (let param in videoInfo.params) {
                                    params[param] = videoInfo.params[param];
                                }
                            }
                            
                            // Create URL
                            let src = urlParser.create({format: 'embed', params: params, videoInfo: videoInfo});

                            // Avoid redirects from youtube.com to www.youtube.com
                            // https://github.com/Zod-/jsVideoUrlParser/pull/48
                            src = src.replace(/^\/\/youtube\.com\//, 'https://www.youtube.com/');

                            // Always use HTTPS
                            src = src.replace(/^\/\//, 'https://');

                            // Embed video
                            $(element).replaceWith('<iframe src="' + src + '"></iframe>');
                        }
                        else {
                            $(element).replaceWith('<img alt="static" src="https://live.cs50.io/static/static-bda124464961813d612f27c1f26eaa52f33bbec4f7d249a126843954c071021c.gif">');
                        }
                    });
                }
                catch (err) {
                    console.log(err);
                }

                // For each iframe
                $('iframe').each(function(index, element) {

                    // Ensure responsive in Safari on iOS (for, e.g., Google Calendars), per https://stackoverflow.com/a/23083463/5156190
                    if (!$(this).attr('scrolling')) {
                        $(this).attr('scrolling', 'no');
                    }

                    // If an embedded YouTube video
                    let matches = $(this).attr('src').match(/^https:\/\/www.youtube.com\/embed\/([A-Za-z0-9_-]+)/);
                    if (matches) {

                        // Add allowfullscreen if not present
                        if ($(this).attr('allowfullscreen') === undefined) {
                            $(this).attr('allowfullscreen', '');
                        }

                        // Add modifier classes if not present, assuming 16x9 by default
                        if (!$(this).hasClass('embed-responsive-item')) {
                            $(this).addClass('embed-responsive-item');
                            $(this).wrap('<div class="embed-responsive embed-responsive-16by9"></div>');
                        }

                        // Add background image for printing
                        // https://stackoverflow.com/a/2068371/5156190
                        if ($(this).css('background-image') === 'none') {
                            $(this).css('background-image', 'url("https://img.youtube.com/vi/' + matches[1] + '/sddefault.jpg")');
                            $(this).css('background-repeat', 'no-repeat');
                            $(this).css('background-size', 'cover');
                        }
                    }
                });

                // Ensure last heading can be anchored atop page
                $(window).resize(function() {
                    let last = $headings.last();
                    if (last.length) {

                        // On small devices
                        if ($('aside').position().top < $('main').position().top) {
                            var margin = $(window).height() - ($('main').outerHeight() + $('aside').outerHeight() - last.offset().top);
                        }

                        // On large devices
                        else {
                            var margin = $(window).height() - ($('main').outerHeight() - last.offset().top);
                        }

                        // Update margin
                        $('main').css('margin-bottom', Math.max(0, Math.ceil(margin)) + 'px');
                    }
                });

                // Reveal Markdown
                $('.markdown-body').show();
                $(window).trigger('resize');
            });

        </script>

        <style>

            /* Hide until shown by JavaScript */
            .markdown-body {
                display: none;
            }

        </style>

        <title>{{ title }}</title>

    </head>

    <body>

        {%- include aside.html -%}

        {%- include main.html -%}

    </body>

</html>
